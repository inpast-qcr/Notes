### 	1.java类和对象

```java
package arraytest;
public class ArrayTest1 {
/*
* 一、设计类，其实就是设计类的成员
*
*  属性 = 成员变量 = field = 域、字段
*  方法 = 成员方法 = 函数 = method
*
*  创建类的对象 = 类的实例化 = 实例化类
*
* 二、类和对象的使用（面向对象思想落地的实现）：
*  1.创建类，设计类的成员
*  2.创建类的对象
*  3.通过“对象.属性”或“对象.方法”调用对象的结构
*
* 三、如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的）
*   意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。
*  
* 四、对象的内存解析
*/
//测试类
    public static void main(String[] args) {
        //2. 创建Person类的对象
        Person p1 = new Person();
        //Scanner scanner = new Scanner(System.in);
         
        //调用对象的结构：属性、方法
        //调用属性：“对象.属性”
        p1.name = "Tom";
        p1.isMale = true;
        System.out.println(p1.name);
         
        //调用方法：“对象.方法”
        p1.eat();
        p1.sleep();
        p1.talk("Chinese");
         
        //*******************************
        Person p2 = new Person();
        System.out.println(p2.name);//null
        System.out.println(p2.isMale);
        //*******************************
        //将p1变量保存的对象地址值赋给p3,导致p1和p3指向了堆空间中的同一个对象实体。
        Person p3 = p1;
        System.out.println(p3.name);//Tom
         
        p3.age = 10;
        System.out.println(p1.age);//10
         
    }
}
//1.创建类，设计类的成员
class Person{
     
    //属性
    String name;
    int age = 1;
    boolean isMale;
     
    //方法
    public void eat(){
        System.out.println("人可以吃饭");
    }
     
    public void sleep(){
        System.out.println("人可以睡觉");
    }
     
    public void talk(String language){
        System.out.println("人可以说话,使用的是：" + language);
    }
     
}
```

****************************

### 2.类中属性的使用

```java
/*
 * 类中属性的使用
 *
 * 属性（成员变量）   vs  局部变量
 * 1.相同点：
 *      1.1  定义变量的格式：数据类型  变量名 = 变量值
 *      1.2 先声明，后使用
 *      1.3 变量都有其对应的作用域
 *
 *
 * 2.不同点：
 *      2.1 在类中声明的位置的不同
 *      属性：直接定义在类的一对{}内
 *      局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
 *     
 *      2.2 关于权限修饰符的不同
 *      属性：可以在声明属性时，指明其权限，使用权限修饰符。
 *          常用的权限修饰符：private、public、缺省、protected  --->封装性
 *          目前，大家声明属性时，都使用缺省就可以了。
 *      局部变量：不可以使用权限修饰符。
 *
 *      2.3 默认初始化值的情况：
 *      属性：类的属性，根据其类型，都有默认初始化值。
 *          整型（byte、short、int、long）：0
 *          浮点型（float、double）：0.0
 *          字符型（char）：0  （或'\u0000'）
 *          布尔型（boolean）：false
 *
 *          引用数据类型（类、数组、接口）：null
 *
 *      局部变量：没有默认初始化值。
 *          意味着，我们在调用局部变量之前，一定要显式赋值。
 *          特别地：形参在调用时，我们赋值即可。
 *
 *      2.4 在内存中加载的位置：
 *      属性：加载到堆空间中   （非static）
 *      局部变量：加载到栈空间
 *
 */
public class UserTest {
     
    public static void main(String[] args) {
        User u1 = new User();
        System.out.println(u1.name);
        System.out.println(u1.age);
        System.out.println(u1.isMale);
         
        u1.talk("韩语");
         
        u1.eat();
         
    }
}
 
class User{
    //属性（或成员变量）
    String name;
    public int age;
    boolean isMale;
     
     
    public void talk(String language){//language:形参，也是局部变量
        System.out.println("我们使用" + language + "进行交流");
         
    }
     
    public void eat(){
        String food = "烙饼";//局部变量
        System.out.println("北方人喜欢吃：" + food);
    }
     
}


```
****************

### 3.类中方法的声明和使用
```java

package com.atguigu.java;
/*
 * 类中方法的声明和使用
 *
 * 方法：描述类应该具有的功能。
 * 比如：Math类：sqrt()\random() \...
 *     Scanner类：nextXxx() ...
 *     Arrays类：sort() \ binarySearch() \ toString() \ equals() \ ...
 *
 * 1.举例：
 * public void eat(){}
 * public void sleep(int hour){}
 * public String getName(){}
 * public String getNation(String nation){}
 *
 * 2. 方法的声明：权限修饰符  返回值类型  方法名(形参列表){
 *                  方法体
 *            }
 *   注意：static、final、abstract 来修饰的方法，后面再讲。
 *  
 * 3. 说明：
 *      3.1 关于权限修饰符：默认方法的权限修饰符先都使用public
 *          Java规定的4种权限修饰符：private、public、缺省、protected  -->封装性再细说
 *
 *      3.2 返回值类型： 有返回值  vs 没有返回值
 *          3.2.1  如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用
 *                return关键字来返回指定类型的变量或常量：“return 数据”。
 *                如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要
 *               使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。
 *
 *          3.2.2 我们定义方法该不该有返回值？
 *              ① 题目要求
 *              ② 凭经验：具体问题具体分析
 *
 *      3.3 方法名：属于标识符，遵循标识符的规则和规范，“见名知意”
 *     
 *      3.4 形参列表： 方法可以声明0个，1个，或多个形参。
 *         3.4.1 格式：数据类型1 形参1,数据类型2 形参2,...
 *        
 *         3.4.2 我们定义方法时，该不该定义形参？
 *              ① 题目要求
 *              ② 凭经验：具体问题具体分析
 *     
 *      3.5 方法体：方法功能的体现。       
 *
 *  4.return关键字的使用：
 *      1.使用范围：使用在方法体中
 *      2.作用：① 结束方法
 *            ② 针对于有返回值类型的方法，使用"return 数据"方法返回所要的数据。
 *      3.注意点：return关键字后面不可以声明执行语句。
 *     
 *  5. 方法的使用中，可以调用当前类的属性或方法
 *          特殊的：方法A中又调用了方法A:递归方法。
 *     方法中，不可以定义方法。
 */
public class CustomerTest {
    public static void main(String[] args) {
         
        Customer cust1 = new Customer();
         
        cust1.eat();
         
        //测试形参是否需要设置的问题
//      int[] arr = new int[]{3,4,5,2,5};
//      cust1.sort();
         
        cust1.sleep(8);
         
    }
}
 
//客户类
class Customer{
     
    //属性
    String name;
    int age;
    boolean isMale;
     
    //方法
    public void eat(){
        System.out.println("客户吃饭");
        return;
        //return后不可以声明表达式
//      System.out.println("hello");
    }
     
    public void sleep(int hour){
        System.out.println("休息了" + hour + "个小时");
         
        eat();
//      sleep(10);
    }
     
    public String getName(){
         
        if(age > 18){
            return name;
             
        }else{
            return "Tom";
        }
    }
     
    public String getNation(String nation){
        String info = "我的国籍是：" + nation;
        return info;
    }
     
    //体会形参是否需要设置的问题
//  public void sort(int[] arr){
//     
//  }
//  public void sort(){
//      int[] arr = new int[]{3,4,5,2,5,63,2,5};
//      //。。。。
//  }
     
    public void info(){
        //错误的
//      public void swim(){
//         
//      }
         
    }
}

```
**********************

### 4.匿名对象
```java

package com.atguigu.java;
/*
 * 一、理解“万事万物皆对象”
 * 1.在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构
 *      >Scanner,String等
 *      >文件：File
 *      >网络资源：URL
 * 2.涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。
 *
 * 二、内存解析的说明
 * 1.引用类型的变量，只可能存储两类值：null  或  地址值（含变量的类型）
 *
 * 三、匿名对象的使用
 * 1.理解：我们创建的对象，没有显式的赋给一个变量名。即为匿名对象
 * 2.特征：匿名对象只能调用一次。
 * 3.使用：如下
 *
 */
public class InstanceTest {
    public static void main(String[] args) {
        Phone p = new Phone();
//      p = null;
        System.out.println(p);
         
        p.sendEmail();
        p.playGame();
         
         
        //匿名对象
//      new Phone().sendEmail();
//      new Phone().playGame();
         
        new Phone().price = 1999;
        new Phone().showPrice();//0.0
         
        //**********************************
        PhoneMall mall = new PhoneMall();
//      mall.show(p);
        //匿名对象的使用
        mall.show(new Phone());
         
    }
}
 
class PhoneMall{
     
     
    public void show(Phone phone){
        phone.sendEmail();
        phone.playGame();
    }
     
}
 
 
class Phone{
    double price;//价格
     
    public void sendEmail(){
        System.out.println("发送邮件");
    }
     
    public void playGame(){
        System.out.println("玩游戏");
    }
     
    public void showPrice(){
        System.out.println("手机价格为：" + price);
    }
     
}

```
********************

### 5.方法的重载
```java

package com.atguigu.java1;
/*
 * 方法的重载（overload）  loading...
 *
 * 1.定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。
 * 
 *  "两同一不同":同一个类、相同方法名
 *            参数列表不同：参数个数不同，参数类型不同
 *
 * 2. 举例：
 *    Arrays类中重载的sort() / binarySearch()
 *
 * 3.判断是否是重载：
 *    跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！
 *   
 * 4. 在通过对象调用方法时，如何确定某一个指定的方法：
 *      方法名 ---> 参数列表
 */
public class OverLoadTest {
    public static void main(String[] args) {
         
        OverLoadTest test = new OverLoadTest();
        test.getSum(1,2);
         
         
    }
     
    //如下的4个方法构成了重载
    public void getSum(int i,int j){
        System.out.println("1");
    }
     
    public void getSum(double d1,double d2){
        System.out.println("2");
    }
     
    public void getSum(String s ,int i){
        System.out.println("3");
    }
     
    public void getSum(int i,String s){
        System.out.println("4");
    }
     
    //如下的3个方法不能与上述4个方法构成重载
//  public int getSum(int i,int j){
//      return 0;
//  }
     
//  public void getSum(int m,int n){
//     
//  }
     
//  private void getSum(int i,int j){
//     
//  }
     
     
}

```
*****************

### 6.可变个数形参的方法
```java

package com.atguigu.java1;
/*
 * 可变个数形参的方法
 *
 * 1.jdk 5.0新增的内容
 * 2.具体使用：
 *   2.1 可变个数形参的格式：数据类型 ... 变量名
 *   2.2 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。
 *   2.3 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载
 *   2.4 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。
 *   2.5 可变个数形参在方法的形参中，必须声明在末尾
 *   2.6  可变个数形参在方法的形参中,最多只能声明一个可变形参。
 *
 */
public class MethodArgsTest {
     
    public static void main(String[] args) {
         
        MethodArgsTest test = new MethodArgsTest();
        test.show(12);
//      test.show("hello");
//      test.show("hello","world");
//      test.show();
         
        test.show(new String[]{"AA","BB","CC"});
         
    }
     
     
    public void show(int i){
         
    }
     
    public void show(String s){
        System.out.println("show(String)");
    }
     
    public void show(String ... strs){
        System.out.println("show(String ... strs)");
         
        for(int i = 0;i < strs.length;i++){
            System.out.println(strs[i]);
        }
    }
    //不能与上一个方法同时存在
//  public void show(String[] strs){
//     
//  }
     
    //The variable argument type String of the method
    //show must be the last parameter
//  public void show(String ...strs,int i){
//     
//  }
     
}

```
*****************

### 7.this关键字
```java

package com.atguigu.java2;
/*
 * this关键字的使用：
 * 1.this可以用来修饰、调用：属性、方法、构造器
 *
 * 2.this修饰属性和方法：
 *   this理解为：当前对象  或 当前正在创建的对象
 *
 *  2.1  在类的方法中，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象属性或方法。但是，
 *   通常情况下，我们都选择省略"this."。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式
 *   的使用"this.变量"的方式，表明此变量是属性，而非形参。
 *
 *  2.2 在类的构造器中，我们可以使用"this.属性"或"this.方法"的方式，调用当前正在创建的对象属性或方法。
 *  但是，通常情况下，我们都选择省略"this."。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式
 *   的使用"this.变量"的方式，表明此变量是属性，而非形参。
 *
 * 3. this调用构造器
 *    ① 我们在类的构造器中，可以显式的使用"this(形参列表)"方式，调用本类中指定的其他构造器
 *    ② 构造器中不能通过"this(形参列表)"方式调用自己
 *    ③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了"this(形参列表)"
 *    ④ 规定："this(形参列表)"必须声明在当前构造器的首行
 *    ⑤ 构造器内部，最多只能声明一个"this(形参列表)"，用来调用其他的构造器
 *
 *
 */
public class PersonTest {
    public static void main(String[] args) {
         
        Person p1 = new Person();
         
        p1.setAge(1);
        System.out.println(p1.getAge());
         
        p1.eat();
         
        System.out.println();
         
        Person p2 = new Person("Jerry",20);
        System.out.println(p2.getAge());
         
    }
}
 
class Person{
     
    private String name;
    private int age;
     
     
    public Person(){
         
//      this.eat();
        String info = "Person初始化时，需要考虑如下的1,2,3,4...(共40行代码)";
        System.out.println(info);
    }
     
    public Person(String name){
        this();
        this.name = name;
         
    }
     
    public Person(int age){
        this();
        this.age = age;
         
    }
     
    public Person(String name,int age){
        this(age);
        this.name = name;
        //this.age = age;
        //Person初始化时，需要考虑如下的1,2,3,4...(共40行代码)
    }
     
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return this.name;
    }
    public void setAge(int age){
        this.age = age;
    }
    public int getAge(){
        return this.age;
    }
     
    public void eat(){
        System.out.println("人吃饭");
        this.study();
    }
    public void study(){
        System.out.println("人学习");
    }
     
}
```
***********************

### 8.封装性
```java

package com.atguigu.java;
/*
 * 面向对象的特征一：封装与隐藏     3W:what? why? how?
 * 一、问题的引入：
 *  当我们创建一个类的对象以后，我们可以通过"对象.属性"的方式，对对象的属性进行赋值。这里，赋值操作要受到
 *  属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值
 *  加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()）
 *  同时，我们需要避免用户再使用"对象.属性"的方式对属性进行赋值。则需要将属性声明为私有的(private).
 *  -->此时，针对于属性就体现了封装性。
 *
 * 二、封装性的体现：
 * 我们将类的属性xxx私有化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值
 *
 *  拓展：封装性的体现：① 如上  ② 不对外暴露的私有的方法  ③ 单例模式   ...
 * 
 *
 * 三、封装性的体现，需要权限修饰符来配合。
 * 1.Java规定的4种权限（从小到大排列）：private、缺省、protected 、public
 * 2.4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类
 * 3.具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类
 *        修饰类的话，只能使用：缺省、public
 *
 * 总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。
 *
 */
public class AnimalTest {
    public static void main(String[] args) {
         
        Animal a = new Animal();
        a.name = "大黄";
//      a.age = 1;
//      a.legs = 4;//The field Animal.legs is not visible
         
        a.show();
         
//      a.legs = -4;
//      a.setLegs(6);
        a.setLegs(-6);
         
//      a.legs = -4;//The field Animal.legs is not visible
        a.show();
         
        System.out.println(a.name);
         
    }
}
 
 
class Animal{
     
    String name;
    private int age;
    private int legs;//腿的个数
     
    //对属性的设置
    public void setLegs(int l){
        if(l >= 0 && l % 2 == 0){
            legs = l;
        }else{
            legs = 0;
//          抛出一个异常（暂时没有讲）
        }
    }
     
    //对属性的获取
    public int getLegs(){
        return legs;
    }
     
     
    public void eat(){
        System.out.println("动物进食");
    }
     
    public void show(){
        System.out.println("name = " + name + ",age = " + age + ",legs = " + legs);
    }
     
    //提供关于属性age的get和set方法
    public int getAge(){
        return age;
    }
    public void setAge(int a){
        age = a;
    }
     
}
```
![](https://inpast-qiq.oss-cn-beijing.aliyuncs.com/img/20210711123024.png)
***********************

### 9.继承性
```java

package com.atguigu.java;
/*
 * 面向对象的特征之二：继承性    why?
 *
 * 一、继承性的好处：
 * ① 减少了代码的冗余，提高了代码的复用性
 * ② 便于功能的扩展
 * ③ 为之后多态性的使用，提供了前提
 *
 *
 * 二、继承性的格式：
 *    class A extends B{}
 *    A:子类、派生类、subclass
 *    B:父类、超类、基类、superclass
 *   
 *    2.1体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。
 *      特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。
 *    只有因为封装性的影响，使得子类不能直接调用父类的结构而已。
 *    2.2 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。
 *    子类和父类的关系，不同于子集和集合的关系。
 *    extends：延展、扩展
 *
 * 三、Java中关于继承性的规定：
 *    1.一个类可以被多个子类继承。
 *    2.Java中类的单继承性：一个类只能有一个父类
 *    3.子父类是相对的概念。
 *    4.子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类
 *    5.子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法
 *   
 * 
 * 四、 1. 如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类
 *    2. 所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类
 *    3. 意味着，所有的java类具有java.lang.Object类声明的功能。
 */
public class ExtendsTest {
    public static void main(String[] args) {
         
        Person p1 = new Person();
//      p1.age = 1;
        p1.eat();
        System.out.println("*****************");
         
        Student s1 = new Student();
        s1.eat();
//      s1.sleep();
        s1.name = "Tom";
        s1.setAge(10);
        System.out.println(s1.getAge());
         
        s1.breath();
         
         
        Creature c = new Creature();
        System.out.println(c.toString());
    }
}
```
**********************

### 10.方法的重写
```java

package com.atguigu.java1;
/*
 * 方法的重写(override / overwrite)
 *
 * 1.重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作
 *
 * 2.应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。
 *
 * 3. 重写的规定：
 *          方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{
 *                      //方法体
 *                  }
 *          约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法
 *      ① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
 *      ② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
 *          >特殊情况：子类不能重写父类中声明为private权限的方法
 *      ③ 返回值类型：
 *          >父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
 *          >父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
 *          >父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)
 *      ④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）
 *  **********************************************************************
 *      子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）。   
 *
 * 面试题：区分方法的重载与重写
 */
 package com.atguigu.java1;
public class PersonTest {
     
    public static void main(String[] args) {
         
        Student s = new Student("计算机科学与技术");
        s.eat();
        s.walk(10);
         
        System.out.println("**************");
         
        s.study();
         
        Person p1 = new Person();
        p1.eat();
         
    }
} 
public class Person {
     
    String name;
    int age;
     
    public Person(){
         
    }
    public Person(String name,int age){
        this.name = name;
        this.age = age;
    }
     
     void eat(){
        System.out.println("吃饭");
    }
    public void walk(int distance){
        System.out.println("走路,走的距离是：" + distance + "公里");
        show();
        eat();
    }
     
    private void show(){
        System.out.println("我是一个人");
    }
     
    public Object info(){
        return null;
    }
     
    public double info1(){
        return 1.0;
    }
 
}

public class Student extends Person{
 
    String major;
     
    public Student(){
         
    }
    public Student(String major){
        this.major = major;
    }
     
    public void study(){
        System.out.println("学习。专业是：" + major);
    }
     
    //对父类中的eat()进行了重写
    public void eat(){
        System.out.println("学生应该多吃有营养的食物");
    }
     
    public void show(){
        System.out.println("我是一个学生");
    }
     
    public String info(){
        return null;
    }
     
//  public int info1(){
//      return 1;
//  }
     
//  public void walk(int distance){
//      System.out.println("重写的方法");
//  }
     
     
    public void walk(int distance) {
        System.out.println("重写的方法");
    }
 
}
```
***************

### 11.super关键字
```java
package com.atguigu.java3;
/*
 * super关键字的使用
 * 1.super理解为：父类的
 * 2.super可以用来调用：属性、方法、构造器
 *
 * 3.super的使用：调用属性和方法
 *
 *   3.1 我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用
 *   父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."
 *   3.2 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的
 *   使用"super.属性"的方式，表明调用的是父类中声明的属性。
 *   3.3 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的
 *   使用"super.方法"的方式，表明调用的是父类中被重写的方法。
 *
 * 4.super调用构造器
 *   4.1  我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
 *   4.2 "super(形参列表)"的使用，必须声明在子类构造器的首行！
 *   4.3 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现
 *   4.4 在构造器的首行，没有显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super()
 *   4.5 在类的多个构造器中，至少有一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器
 */
public class SuperTest {
    public static void main(String[] args) {
         
        Student s = new Student();
        s.show();
         
        System.out.println();
         
        s.study();
         
        Student s1 = new Student("Tom", 21, "IT");
        s1.show();
         
        System.out.println("************");
        Student s2 = new Student();
         
    }
}

public class Person {
    String name;
    int age;
    int id = 1001;//身份证号
     
    public Person(){
        System.out.println("我无处不在！");
    }
     
    public Person(String name){
        this.name = name;
    }
     
    public Person(String name,int age){
        this(name);
        this.age = age;
    }
     
    public void eat(){
        System.out.println("人：吃饭");
    }
    public void walk(){
        System.out.println("人：走路");
    }
}

public class Student extends Person{
     
    String major;
    int id = 1002;//学号
     
    public Student(){
        super();
    }
    public Student(String major){
        super();
        this.major = major;
    }
     
    public Student(String name,int age,String major){
//      this.name = name;
//      this.age = age;
        super(name,age);
        this.major = major;
    }
     
    @Override
    public void eat() {
        System.out.println("学生：多吃有营养的食物");
    }
     
    public void study(){
        System.out.println("学生：学习知识");
        this.eat();
        super.eat();
        walk();
    }
     
    public void show(){
        System.out.println("name = " + name + ", age = " + age);
        System.out.println("id = " + this.id);
        System.out.println("id = " + super.id);
    }
}
```
************************

### 12.多态性
```java
package com.atguigu.java4;
 
/*
 * 面向对象特征之三：多态性
 *
 * 1.理解多态性：可以理解为一个事物的多种形态。
 * 2.何为多态性：
 *   对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）
 *  
 * 3. 多态的使用：虚拟方法调用
 *   有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。
 *   总结：编译，看左边；运行，看右边。
 *  
 * 4.多态性的使用前提：  ① 类的继承关系  ② 方法的重写
 *
 * 5.对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）
 
* abstract不能用来修饰：属性、构造器等结构

* abstract不能用来修饰私有方法、静态方法、final的方法、final的类
 */
public class PersonTest {
     
     
    public static void main(String[] args) {
         
        Person p1 = new Person();
        p1.eat();
         
        Man man = new Man();
        man.eat();
        man.age = 25;
        man.earnMoney();
         
        //*************************************************
        System.out.println("*******************");
        //对象的多态性：父类的引用指向子类的对象
        Person p2 = new Man();
//      Person p3 = new Woman();
        //多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法 ---虚拟方法调用
        p2.eat();
        p2.walk();
         
//      p2.earnMoney();
         
        System.out.println(p2.id);//1001
         
    }
}

public class Person {
    String name;
    int age;
     
    int id = 1001;
     
    public void eat(){
        System.out.println("人：吃饭");
    }
     
    public void walk(){
        System.out.println("人：走路");
    }
     
}

public class Man extends Person{
     
    boolean isSmoking;
     
    int id = 1002;
     
    public void earnMoney(){
        System.out.println("男人负责挣钱养家");
    }
     
    public void eat(){
        System.out.println("男人多吃肉，长肌肉");
    }
     
    public void walk(){
        System.out.println("男人霸气的走路");
    }
 
}

public class Woman extends Person{
     
    boolean isBeauty;
     
    public void goShopping(){
        System.out.println("女人喜欢购物");
    }
     
    public void eat(){
        System.out.println("女人少吃，为了减肥");
    }
     
    public void walk(){
        System.out.println("女人窈窕的走路");
    }
}
```
********************

### 13.向下转型
```java
class Person{}
class Man extends Person{}

// 向上转型，体现了多态
Person p1 = new Man();
// 向下转型，使子类对象能调用父类对象中未重写的属性和方法，使用强转时可能出现 classException(转换错误)
Man m1 = (Man)p1;

//  a  instanceof  A :判断对象 a 是否是类 A 的实例，是返回 true ,不是返回 false
// 若 B 是 A 的父类且 a  instanceof  A 返回 true，则 a instanceof B 也返回true
if(p1 instanceof Woman){
    Woman w1 = (Woman)p2;
    w1.goShopping;
}
```
******************

### 14.equals();方法

```java
import java.util.Date;
 
/*equals();方法
 *
 * 面试题： == 和 equals() 区别
 *
 * 一、回顾 == 的使用：
 * == ：运算符
 * 1. 可以使用在基本数据类型变量和引用数据类型变量中
 * 2. 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）
 *    如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体
 * 补充： == 符号使用时，必须保证符号左右两边的变量类型一致。
 *
 * 二、equals()方法的使用：
 * 1. 是一个方法，而非运算符
 * 2. 只能适用于引用数据类型
 * 3. Object类中equals()的定义：
 *    public boolean equals(Object obj) {
            return (this == obj);
      }
 *    说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体
 *
 * 4. 像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是
 *    两个引用的地址是否相同，而是比较两个对象的"实体内容"是否相同。
 *   
 * 5. 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的"实体内容"是否相同。那么，我们
 *    就需要对Object类中的equals()进行重写.
 *    重写的原则：比较两个对象的实体内容是否相同.
 */
public class EqualsTest {
    public static void main(String[] args) {
         
        //基本数据类型
        int i = 10;
        int j = 10;
        double d = 10.0;
        System.out.println(i == j);//true
        System.out.println(i == d);//true,会有自动类型提升
         
        boolean b = true;
//      System.out.println(i == b);
         
        char c = 10;
        System.out.println(i == c);//true
         
        char c1 = 'A';
        char c2 = 65;
        System.out.println(c1 == c2);//true
         
        //引用类型：
        Customer cust1 = new Customer("Tom",21);
        Customer cust2 = new Customer("Tom",21);
        System.out.println(cust1 == cust2);//false
         
        String str1 = new String("atguigu");
        String str2 = new String("atguigu");
        System.out.println(str1 == str2);//false
        System.out.println("****************************");
        System.out.println(cust1.equals(cust2));//false--->true
        System.out.println(str1.equals(str2));//true
         
        Date date1 = new Date(32432525324L);
        Date date2 = new Date(32432525324L);
        System.out.println(date1.equals(date2));//true
         
         
    }
}

public class Customer {
     
    private String name;
    private int age;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public Customer() {
        super();
    }
    public Customer(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
 
    //自动生成的equals()
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Customer other = (Customer) obj;
        if (age != other.age)
            return false;
        if (name == null) {
            if (other.name != null)
                return false;
        } else if (!name.equals(other.name))
            return false;
        return true;
    }
     
     
     
    //重写的原则：比较两个对象的实体内容(即：name和age)是否相同
    //手动实现equals()的重写
//  @Override
//  public boolean equals(Object obj) {
//     
////        System.out.println("Customer equals()....");
//      if (this == obj) {
//            return true;
//        }
//     
//      if(obj instanceof Customer){
//          Customer cust = (Customer)obj;
//          //比较两个对象的每个属性是否都相同
////            if(this.age == cust.age && this.name.equals(cust.name)){
////                return true;
////            }else{
////                return false;
////            }
//         
//          //或
//          return this.age == cust.age && this.name.equals(cust.name);
//      }else{
//          return false;
//         
//      }
//     
//  }
    //手动实现
//  @Override
//  public String toString() {
//      return "Customer[name = " + name + ",age = " + age + "]";
//  }
    //自动实现
    @Override
    public String toString() {
        return "Customer [name=" + name + ", age=" + age + "]";
    }
}

```
********************

### 15.toString(); 方法

```java
import java.util.Date;
 
/*
 * Object类中toString()的使用：
 *
 * 1. 当我们输出一个对象的引用时，实际上就是调用当前对象的toString()
 *
 * 2. Object类中toString()的定义：
 *   public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
     }
 *
 * 3. 像String、Date、File、包装类等都重写了Object类中的toString()方法。
 *    使得在调用对象的toString()时，返回"实体内容"信息
 *   
 * 4. 自定义类也可以重写toString()方法，当调用此方法时，返回对象的"实体内容"
 */
public class ToStringTest {
    public static void main(String[] args) {
         
        Customer cust1 = new Customer("Tom",21);
        System.out.println(cust1.toString());//com.atguigu.java1.Customer@15db9742-->Customer[name = Tom,age = 21]
        System.out.println(cust1);//com.atguigu.java1.Customer@15db9742-->Customer[name = Tom,age = 21]
         
        String str = new String("MM");
        System.out.println(str);//MM
         
        Date date = new Date(4534534534543L);
        System.out.println(date.toString());//Mon Sep 11 08:55:34 GMT+08:00 2113
         
    }
}

```

**********************
### 16. 包装类

<img src="https://inpast-qiq.oss-cn-beijing.aliyuncs.com/img/20210711123059.png"  />

```java
import org.junit.Test;
 
/*
 * 包装类的使用:
 * 1.java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征
 *
 * 2.掌握的：基本数据类型、包装类、String三者之间的相互转换
 *
 *
 *
 */
public class WrapperTest {
     
    //String类型 --->基本数据类型、包装类：调用包装类的parseXxx(String s)
    @Test
    public void test5(){
        String str1 = "123";
        //错误的情况：
//      int num1 = (int)str1;
//      Integer in1 = (Integer)str1;
        //可能会报NumberFormatException
        int num2 = Integer.parseInt(str1);
        System.out.println(num2 + 1);
         
        String str2 = "true1";
        boolean b1 = Boolean.parseBoolean(str2);//不是标准的 "true"，则返回 false 值
        System.out.println(b1);
    }
     
    //基本数据类型、包装类--->String类型：调用String重载的valueOf(Xxx xxx)
    @Test
    public void test4(){
         
        int num1 = 10;
        //方式1：连接运算
        String str1 = num1 + "";
        //方式2：调用String的valueOf(Xxx xxx)
        float f1 = 12.3f;
        String str2 = String.valueOf(f1);//"12.3"
         
        Double d1 = new Double(12.4);
        String str3 = String.valueOf(d1);
        System.out.println(str2);
        System.out.println(str3);//"12.4"
         
    }
     
    /*
     * JDK 5.0 新特性：自动装箱 与自动拆箱
     */
    @Test
    public void test3(){
//      int num1 = 10;
//      //基本数据类型-->包装类的对象
//      method(num1);
         
        //自动装箱：基本数据类型 --->包装类
        int num2 = 10;
        Integer in1 = num2;//自动装箱
         
        boolean b1 = true;
        Boolean b2 = b1;//自动装箱
         
        //自动拆箱：包装类--->基本数据类型
        System.out.println(in1.toString());
         
        int num3 = in1;//自动拆箱
         
    }
     
    public void method(Object obj){
        System.out.println(obj);
    }
     
    //包装类--->基本数据类型:调用包装类Xxx的xxxValue()
    @Test
    public void test2(){
        Integer in1 = new Integer(12);
         
        int i1 = in1.intValue();
        System.out.println(i1 + 1);
         
         
        Float f1 = new Float(12.3);
        float f2 = f1.floatValue();
        System.out.println(f2 + 1);
    }
     
    //基本数据类型 --->包装类：调用包装类的构造器
    @Test
    public void test1(){
         
        int num1 = 10;
//      System.out.println(num1.toString());
        Integer in1 = new Integer(num1);
        System.out.println(in1.toString());
         
        Integer in2 = new Integer("123");
        System.out.println(in2.toString());
         
        //报异常，不是纯粹的数
//      Integer in3 = new Integer("123abc");
//      System.out.println(in3.toString());
         
        Float f1 = new Float(12.3f);
        Float f2 = new Float("12.3");
        System.out.println(f1);
        System.out.println(f2);
         
        Boolean b1 = new Boolean(true);
        //Boolean类进行过重写，不论不小写输入的 String 类型都正确
        Boolean b2 = new Boolean("TrUe");
        System.out.println(b2);
        Boolean b3 = new Boolean("true123");
        System.out.println(b3);//false
         
         
        Order order = new Order();
        System.out.println(order.isMale);//false
        System.out.println(order.isFemale);//null，声明的是一个类
    }
     
}
 
class Order{
     
    boolean isMale;
    Boolean isFemale;
}

```

***********************

### 17.static关键字

```java
/*
 * static关键字的使用
 *
 * 1.static:静态的
 * 2.static可以用来修饰：属性、方法、代码块、内部类
 *
 * 3.使用static修饰属性：静态变量（或类变量）
 *      3.1 属性，按是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)
 *         实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的
 *              非静态属性时，不会导致其他对象中同样的属性值的修改。
 *       静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致
 *              其他对象调用此静态变量时，是修改过了的。
 *      3.2 static修饰属性的其他说明：
 *          ① 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用
 *          ② 静态变量的加载要早于对象的创建。
 *          ③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。
 *         
 *          ④       类变量 实例变量
 *          类       yes     no
 *          对象      yes     yes
 *         
 *      3.3 静态属性举例：System.out; Math.PI;
 *
 * 4.使用static修饰方法：静态方法
 *      ① 随着类的加载而加载，可以通过"类.静态方法"的方式进行调用
 *      ②           静态方法    非静态方法
 *          类       yes     no
 *          对象      yes     yes
 *      ③ 静态方法中，只能调用静态的方法或属性
 *        非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性
 *
 * 5. static注意点：
 *    5.1 在静态的方法内，不能使用this关键字、super关键字
 *    5.2 关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。
 *   
 * 6. 开发中，如何确定一个属性是否要声明为static的？
 *      > 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。
 *      > 类中的常量也常常声明为static
 *
 *    开发中，如何确定一个方法是否要声明为static的？
 *      > 操作静态属性的方法，通常设置为static的
 *      > 工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections
 */
public class StaticTest {
    public static void main(String[] args) {
         
        Chinese.nation = "中国";
         
         
        Chinese c1 = new Chinese();
        c1.name = "姚明";
        c1.age = 40;
        c1.nation = "CHN";
         
        Chinese c2 = new Chinese();
        c2.name = "马龙";
        c2.age = 30;
        c2.nation = "CHINA";
         
        System.out.println(c1.nation);
         
        //编译不通过
//      Chinese.name = "张继科";
         
         
        c1.eat();
         
        Chinese.show();
        //编译不通过
//      Chinese.eat();
//      Chinese.info();
    }
}
//中国人
class Chinese{
     
    String name;
    int age;
    static String nation;
     
     
    public void eat(){
        System.out.println("中国人吃中餐");
        //调用非静态结构
        this.info();
        System.out.println("name :" +name);
        //调用静态结构
        walk();
        System.out.println("nation : " + nation);
    }
     
    public static void show(){
        System.out.println("我是一个中国人！");
        //不能调用非静态的结构
//      eat();
//      name = "Tom";
        //可以调用静态的结构
        System.out.println(Chinese.nation);
        walk();
    }
     
    public void info(){
        System.out.println("name :" + name +",age : " + age);
    }
     
    public static void walk(){
         
    }
}

```


******************************

### 18.final关键字

```java
/*
 * final:最终的
 *
 * 1. final可以用来修饰的结构：类、方法、变量
 *
 * 2. final 用来修饰一个类:此类不能被其他类所继承。
 *          比如：String类、System类、StringBuffer类
 *
 * 3. final 用来修饰方法：表明此方法不可以被重写
 *          比如：Object类中getClass();
 *
 * 4. final 用来修饰变量：此时的"变量"就称为是一个常量
 *      4.1 final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化
 *      4.2 final修饰局部变量：
 *           尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值
 *           以后，就只能在方法体内使用此形参，但不能进行重新赋值。
 *          
 *  static final 用来修饰属性：全局常量
 */
public class FinalTest {
     
    final int WIDTH = 0;
    final int LEFT;
    final int RIGHT;
//  final int DOWN;代码块中赋值
     
    {
        LEFT = 1;
    }
     // 构造器中赋值初始化
    public FinalTest(){
        RIGHT = 2;
    }
     //构造器中初始化时，所有的构造器都要初始化，但赋的值可以不同
    public FinalTest(int n){
        RIGHT = n;
    }
     
//  public void setDown(int down){
//      this.DOWN = down;
//  }
// 方法中不能给方法赋值
     
     
    public void doWidth(){
//      width = 20;
    }
     
     
    public void show(){
        final int NUM = 10;//常量
//      NUM += 20;
    }
     
    public void show(final int num){
//      num = 20;//编译不通过
        System.out.println(num);
    }
     
     
    public static void main(String[] args) {
         
        int num = 10;
         
        num = num + 5;
         
        FinalTest test = new FinalTest();
//      test.setDown(3);
         
        test.show(10);
    }
}
 
 
final class FinalA{
     
}
 
//class B extends FinalA{
// 
//}
 
//class C extends String{
// 
//}
 
class AA{
    public final void show(){
         
    }
}
 
class BB extends AA{
     
//  public void show(){
//     
//  }
}
```
*******************
### 19. 代码块

```java
/*
 * 类的成员之四：代码块（或初始化块）
 *
 * 1. 代码块的作用：用来初始化类、对象
 * 2. 代码块如果有修饰的话，只能使用static.
 * 3. 分类：静态代码块  vs 非静态代码块
 *
 * 4. 静态代码块
 *     >内部可以有输出语句
 *     >随着类的加载而执行,而且只执行一次
 *     >作用：初始化类的信息
 *     >如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行
 *     >静态代码块的执行要优先于非静态代码块的执行
 *     >静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构
 *
 * 5. 非静态代码块
 *      >内部可以有输出语句
 *      >随着对象的创建而执行
 *      >每创建一个对象，就执行一次非静态代码块
 *      >作用：可以在创建对象时，对对象的属性等进行初始化
 *      >如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行
 *      >非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法
 *
 */
public class BlockTest {
    public static void main(String[] args) {
         
        String desc = Person.desc;
        System.out.println(desc);
         
        Person p1 = new Person();
        Person p2 = new Person();
        System.out.println(p1.age);
         
        Person.info();
    }
}
 
 
class Person{
    //属性
    String name;
     
    int age;
 
    static String desc = "我是一个人";
     
    //构造器
    public Person(){
         
    }
    public Person(String name,int age){
        this.name = name;
        this.age = age;
    }
     
    //非static的代码块
    {
        System.out.println("hello, block - 2");
    }
    {
        System.out.println("hello, block - 1");
        //调用非静态结构
        age = 1;
        eat();
        //调用静态结构
        desc = "我是一个爱学习的人1";
        info();
    }
    //static的代码块
    static{
        System.out.println("hello,static block-2");
    }
    static{
        System.out.println("hello,static block-1");
        //调用静态结构
        desc = "我是一个爱学习的人";
        info();
        //不可以调用非静态结构
//      eat();
//      name = "Tom";
    }
     
    //方法
    public void eat(){
        System.out.println("吃饭");
    }
    @Override
    public String toString() {
        return "Person [name=" + name + ", age=" + age + "]";
    }
    public static void info(){
        System.out.println("我是一个快乐的人！");
    }
     
}

```

******************

### 20.抽象类
```java

package com.atguigu.java;
/*
 * abstract关键字的使用
 * 1.abstract:抽象的
 * 2.abstract可以用来修饰的结构：类、方法
 *
 * 3. abstract修饰类：抽象类
 *      > 此类不能实例化
 *      > 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）
 *      > 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作
 *
 *
 * 4. abstract修饰方法：抽象方法
 *      > 抽象方法只有方法的声明，没有方法体
 *      > 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。
 *      > 若子类重写了父类中的所有的抽象方法后，此子类方可实例化
 *        若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰
 */
public class AbstractTest {
    public static void main(String[] args) {
         
        //一旦Person类抽象了，就不可实例化
//      Person p1 = new Person();
//      p1.eat();
         
    }
}
 
abstract class Creature{
    public abstract void breath();
}
 
abstract class Person extends Creature{
    String name;
    int age;
     
    public Person(){
         
    }
    public Person(String name,int age){
        this.name = name;
        this.age = age;
    }
     
    //不是抽象方法：
//  public void eat(){
//     
//  }


    //抽象方法
    public abstract void eat();
     
    public void walk(){
        System.out.println("人走路");
    }
     
     
}
 
 
class Student extends Person{
     
    public Student(String name,int age){
        super(name,age);
    }
    public Student(){
    }
     
    public void eat(){
        System.out.println("学生多吃有营养的食物");
    }
 
    @Override
    public void breath() {
        System.out.println("学生应该呼吸新鲜的没有雾霾的空气");
    }
}

/*
 * 抽象类的匿名子类
 *
 */
public class PersonTest {
     
    public static void main(String[] args) {
         
        method(new Student());//匿名对象
         
        Worker worker = new Worker();
        method1(worker);//非匿名的类非匿名的对象
         
        method1(new Worker());//非匿名的类匿名的对象
         
        System.out.println("********************");
         
        //创建了一匿名子类的对象：p
        Person p = new Person(){
 
            @Override
            public void eat() {
                System.out.println("吃东西");
            }
 
            @Override
            public void breath() {
                System.out.println("好好呼吸");
            }
             
        };
         
        method1(p);
        System.out.println("********************");
        //创建匿名子类的匿名对象
        method1(new Person(){
            @Override
            public void eat() {
                System.out.println("吃好吃东西");
            }
 
            @Override
            public void breath() {
                System.out.println("好好呼吸新鲜空气");
            }
        });
    }
     
     
    public static void method1(Person p){
        p.eat();
        p.breath();
    }
     
    public static void method(Student s){
         
    }
}
 
class Worker extends Person{
 
    @Override
    public void eat() {
    }
 
    @Override
    public void breath() {
    }
     
}
```
**********************

### 21.接口
```java

package com.atguigu.java1;
/*
 * 接口的使用
 * 1.接口使用interface来定义
 * 2.Java中，接口和类是并列的两个结构
 * 3.如何定义接口：定义接口中的成员
 *     
 *      3.1 JDK7及以前：只能定义全局常量和抽象方法
 *          >全局常量：public static final的.但是书写时，可以省略不写
 *          >抽象方法：public abstract的
 *         
 *      3.2 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）
                          //静态方法，只能用接口名 . 来调用，在实现子类中无法使用
    				public static void method1(){
       				  System.out.println("CompareA:北京");
    				}
    			//默认方法，通过实现类的对象来调用，可以重写
                                public default void method2(){
                                    System.out.println("CompareA：上海");
                                }
 *
 * 4. 接口中不能定义构造器的！意味着接口不可以实例化
 *
 * 5. Java开发中，接口通过让类去实现(implements)的方式来使用.
 *    如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化
 *    如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类
 *   
 * 6. Java类可以实现多个接口   --->弥补了Java单继承性的局限性
 *   格式：class AA extends BB implements CC,DD,EE
 *  
 * 7. 接口与接口之间可以继承，而且可以多继承
 *
 * *******************************
 * 8. 接口的具体使用，体现多态性
 * 9. 接口，实际上可以看做是一种规范
 *
 * 面试题：抽象类与接口有哪些异同？
 *
 */
public class InterfaceTest {
    public static void main(String[] args) {
        System.out.println(Flyable.MAX_SPEED);
        System.out.println(Flyable.MIN_SPEED);
//      Flyable.MIN_SPEED = 2;
         
        Plane plane = new Plane();
        plane.fly();
    }
}
 
 
interface Flyable{
     
    //全局常量
    public static final int MAX_SPEED = 7900;//第一宇宙速度
    int MIN_SPEED = 1;//书写时可以省略public static final
     
    //抽象方法
    public abstract void fly();
    //省略了public abstract
    void stop();
     
     
    //Interfaces cannot have constructors
//  public Flyable(){
//     
//  }
}
 
interface Attackable{
     
    void attack();
     
}
 //实现类重写了接口中的抽象方法
class Plane implements Flyable{
 
    @Override
    public void fly() {
        System.out.println("通过引擎起飞");
    }
 
    @Override
    public void stop() {
        System.out.println("驾驶员减速停止");
    }
     
}
 //未重写接口中所有的抽象方法，表明这还是一个抽象类
abstract class Kite implements Flyable{
 
    @Override
    public void fly() {
         
    }
     
}
//  一个类可以实现多个接口并用逗号隔开，先继承父类，后实现接口
//  当子类（实现类）继承的父类和实现的接口中出现同名同参数的方法，那么子类在没有重写此方法的情况下，调用的是        父类的方法，使用接口中的默认方法：接口名.super.方法名
//  多实现中的接口同时出现同名同参数的方法时，在实现类未重写的情况下会冲突，需要在实现类中重写才能编译成功
class Bullet extends Object implements Flyable,Attackable,CC{
 
    @Override
    public void attack() {
        // TODO Auto-generated method stub
         
    }
 
    @Override
    public void fly() {
        // TODO Auto-generated method stub
         
    }
 
    @Override
    public void stop() {
        // TODO Auto-generated method stub
         
    }
 
    @Override
    public void method1() {
        // TODO Auto-generated method stub
         
    }
 
    @Override
    public void method2() {
        // TODO Auto-generated method stub
         
    }
     
}
//************************************
 
interface AA{
    void method1();
}
interface BB{
     
    void method2();
}
 //接口之间可以多继承
interface CC extends AA,BB{
     
}
```
******************

### 22.接口的应用
```java

package com.atguigu.java1;
/*
 * 接口的使用
 * 1.接口使用上也满足多态性
 * 2.接口，实际上就是定义了一种规范
 * 3.开发中，体会面向接口编程！
 *
 */
public class USBTest {
    public static void main(String[] args) {
         
        Computer com = new Computer();
        //1.创建了接口的非匿名实现类的非匿名对象
        Flash flash = new Flash();
        com.transferData(flash);
         
        //2. 创建了接口的非匿名实现类的匿名对象
        com.transferData(new Printer());
         
        //3. 创建了接口的匿名实现类的非匿名对象
        USB phone = new USB(){
 
            @Override
            public void start() {
                System.out.println("手机开始工作");
            }
 
            @Override
            public void stop() {
                System.out.println("手机结束工作");
            }
             
        };
        com.transferData(phone);
         
         
        //4. 创建了接口的匿名实现类的匿名对象
         
        com.transferData(new USB(){
            @Override
            public void start() {
                System.out.println("mp3开始工作");
            }
 
            @Override
            public void stop() {
                System.out.println("mp3结束工作");
            }
        });
    }
}
 
class Computer{
     
    public void transferData(USB usb){//USB usb = new Flash();
        usb.start();
         
        System.out.println("具体传输数据的细节");
         
        usb.stop();
    }
     
     
}
 
interface USB{
    //常量：定义了长、宽、最大最小的传输速度等
     
    void start();
     
    void stop();
     
}
 
class Flash implements USB{
 
    @Override
    public void start() {
        System.out.println("U盘开启工作");
    }
 
    @Override
    public void stop() {
        System.out.println("U盘结束工作");
    }
     
}
 
class Printer implements USB{
    @Override
    public void start() {
        System.out.println("打印机开启工作");
    }
 
    @Override
    public void stop() {
        System.out.println("打印机结束工作");
    }
     
}
```


**************

### 23. 内部类

```java
/*
 * 类的内部成员之五：内部类
 * 1. Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类
 *
 * 2.内部类的分类：成员内部类（静态、非静态）  vs 局部内部类(方法内、代码块内、构造器内)
 *
 * 3.成员内部类：
 *      一方面，作为外部类的成员：
 *          >调用外部类的结构
 *          >可以被static修饰
 *          >可以被4种不同的权限修饰
 *
 *      另一方面，作为一个类：
 *          > 类内可以定义属性、方法、构造器等
 *          > 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承
 *          > 可以被abstract修饰
 *
 *
 * 4.关注如下的3个问题
 *   4.1 如何实例化成员内部类的对象
 *   4.2 如何在成员内部类中区分调用外部类的结构
 *   4.3 开发中局部内部类的使用  见《InnerClassTest1.java》
 *
 */
public class InnerClassTest {
    public static void main(String[] args) {
         
        //创建Dog实例(静态的成员内部类):
        Person.Dog dog = new Person.Dog();
        dog.show();
        //创建Bird实例(非静态的成员内部类):，非静态的需要创建对象实例
//      Person.Bird bird = new Person.Bird();//错误的
        Person p = new Person();
        Person.Bird bird = p.new Bird();
        bird.sing();
         
        System.out.println();
         
        bird.display("黄鹂");
         
    }
}
 
 
class Person{
     
    String name = "小明";
    int age;
     
    public void eat(){
        System.out.println("人：吃饭");
    }
     
     
    //静态成员内部类
    static class Dog{
        String name;
        int age;
         
        public void show(){
            System.out.println("卡拉是条狗");
//          eat();
        }
         
    }
    //非静态成员内部类
    class Bird{
        String name = "杜鹃";
         
        public Bird(){
             
        }
         
        public void sing(){
            System.out.println("我是一只小小鸟");
            Person.this.eat();//调用外部类的非静态属性
            eat();
            System.out.println(age);
        }
//属性重名时的调用
        public void display(String name){
            System.out.println(name);//方法的形参
            System.out.println(this.name);//内部类的属性
            System.out.println(Person.this.name);//外部类的属性
        }
    }
     
     
    public void method(){
        //局部内部类（方法）
        class AA{
             
        }
    }
     
    {
        //局部内部类（代码块）
        class BB{
             
        }
    }
     
    public Person(){
        //局部内部类（构造器）
        class CC{
             
        }
    }
     
     
     
}

```

***********

